var documenterSearchIndex = {"docs":
[{"location":"dataset/","page":"Instance generator","title":"Instance generator","text":"EditURL = \"https://github.com/BatyLeo/StochasticVehicleScheduling.jl/blob/main/docs/src/literate/dataset.jl\"","category":"page"},{"location":"dataset/#Instance-generator","page":"Instance generator","title":"Instance generator","text":"","category":"section"},{"location":"dataset/","page":"Instance generator","title":"Instance generator","text":"This package implements an instance generator, which can be used with the create_random_instance method.","category":"page"},{"location":"dataset/","page":"Instance generator","title":"Instance generator","text":"For example, we can create a random instance with 10 tasks and 10 scenarios and plot it:","category":"page"},{"location":"dataset/","page":"Instance generator","title":"Instance generator","text":"using StochasticVehicleScheduling\ninstance = create_random_instance(; nb_tasks=10, nb_scenarios=10)\n\nusing Plots\nfig = plot()\nfor i in 1:(get_nb_tasks(instance) + 1)\n    task = instance.city.tasks[i]\n    (; start_point, end_point) = task\n    points = [(start_point.x, start_point.y), (end_point.x, end_point.y)]\n    plot!(fig, points; color=:black, label=\"\")\n    scatter!(\n        fig,\n        points;\n        marker=:rect,\n        markersize=10,\n        label=\"\",\n        series_annotations=[(\"$(i-1)\", 9), \"\"],\n    )\nend\nsavefig(fig, \"instance2.png\"); # hide\nnothing #hide","category":"page"},{"location":"dataset/","page":"Instance generator","title":"Instance generator","text":"(Image: instance2) This instance object can be used as input of all algorithms implemented in this package. More details on its attributes and how they are computed are provided bellow but not needed in order to experiment with this package.","category":"page"},{"location":"dataset/#City","page":"Instance generator","title":"City","text":"","category":"section"},{"location":"dataset/","page":"Instance generator","title":"Instance generator","text":"When creating an instance, we first create a StochasticVehicleScheduling.City object. By default, a City is a squared map of 50 minutes width, divided in 25 squared (10 minutes width) districts (cf. the example plot above). The depot is located at the center of the map. Each task v has an (uniformly drawn) start point, start time t_v^b, end point, and end time t_v^e.","category":"page"},{"location":"dataset/","page":"Instance generator","title":"Instance generator","text":"For each scenario sin S, we roll multiple random variables.","category":"page"},{"location":"dataset/","page":"Instance generator","title":"Instance generator","text":"For each district d and hour h of the day, beta_d h are independent log-normal variables with randomly (uniform) drawn parameters (mu sigma)in 1 3times 04 06.","category":"page"},{"location":"dataset/","page":"Instance generator","title":"Instance generator","text":"For each district d and hour h of the day, zeta_dh^dis models the congestion in the district at this time.","category":"page"},{"location":"dataset/","page":"Instance generator","title":"Instance generator","text":"begincases\n    forall d zeta^dis_d 0 = beta_d0\n    forall dh zeta^dis_d h+1 = frac12zeta^dis_d h + beta_dh\nendcases","category":"page"},{"location":"dataset/","page":"Instance generator","title":"Instance generator","text":"For each hour h of the day, zeta^inter_h models the congestion on roads between districts, and is computed similarly:","category":"page"},{"location":"dataset/","page":"Instance generator","title":"Instance generator","text":"begincases\n    zeta^inter_0 = I\n    zeta^inter_h+1 = (zeta^inter_h + 01)I\nendcases","category":"page"},{"location":"dataset/","page":"Instance generator","title":"Instance generator","text":"with Isim logmathcalN(002 005).","category":"page"},{"location":"dataset/","page":"Instance generator","title":"Instance generator","text":"Let v be a task corresponding to a trip between district d_1 and d_2. We compute the perturbed start and end times:","category":"page"},{"location":"dataset/","page":"Instance generator","title":"Instance generator","text":"begincases\n    xi_v^b = t_v^b + beta_v\n    xi_v^e = xi_v^b + t_v^e - t_v^b + zeta^dis_d_1h(xi_1) + zeta^inter_h(xi_2) + zeta^dis_d_2 h(xi_3)\nendcases","category":"page"},{"location":"dataset/","page":"Instance generator","title":"Instance generator","text":"with xi_1 = xi_v^b, xi_2 = xi_1 + zeta^dis_d_1h(xi_1), and xi_3 = xi_2 + t_v^e - t_v^b + xi^inter_h(xi_2).","category":"page"},{"location":"dataset/","page":"Instance generator","title":"Instance generator","text":"Finally, for any a=(uv), we compute the perturbed travel time:","category":"page"},{"location":"dataset/","page":"Instance generator","title":"Instance generator","text":"xi_a^tr = xi_v^b + t_a^tr + zeta^dis_d_1h(xi_1) + zeta^inter_h(xi_2) + zeta^dis_d_2 h(xi_3) with xi_1 = xi_u^e, xi_2 = xi_1 + zeta^dis_d_1h(xi_1), andxi_3 = xi_2 + t_a^tr + xi^inter_h(xi_2).","category":"page"},{"location":"dataset/","page":"Instance generator","title":"Instance generator","text":"The function create_random_city can be used to create cities with modified default options.","category":"page"},{"location":"dataset/#Graph","page":"Instance generator","title":"Graph","text":"","category":"section"},{"location":"dataset/","page":"Instance generator","title":"Instance generator","text":"Once the City object is generated, we can compute an associated acyclic digraph D, as described in the Problem statement.","category":"page"},{"location":"dataset/#Features","page":"Instance generator","title":"Features","text":"","category":"section"},{"location":"dataset/","page":"Instance generator","title":"Instance generator","text":"An instance contains a matrix of 20 features for every arc of the corresponding graph :","category":"page"},{"location":"dataset/","page":"Instance generator","title":"Instance generator","text":"Length of the arc in minutes (deterministic travel time).\nCost of a vehicle if the arc is connected to the source.\nThe 9 deciles of the slack xi_v^b - (xi_u^e + xi_a^tr).\nThe cumulative probability distribution of the slack, evaluated in -100 -50 -20 -10 0 50 200 500.","category":"page"},{"location":"dataset/","page":"Instance generator","title":"Instance generator","text":"","category":"page"},{"location":"dataset/","page":"Instance generator","title":"Instance generator","text":"This page was generated using Literate.jl.","category":"page"},{"location":"paper/#Reproducing-paper-experiments","page":"Reproducing paper experiments","title":"Reproducing paper experiments","text":"","category":"section"},{"location":"paper/","page":"Reproducing paper experiments","title":"Reproducing paper experiments","text":"All the scripts needed to reproduce experiments from the paper can be found in the scripts folder.","category":"page"},{"location":"paper/","page":"Reproducing paper experiments","title":"Reproducing paper experiments","text":"Once downloaded, you need to instantiate the julia environment:","category":"page"},{"location":"paper/","page":"Reproducing paper experiments","title":"Reproducing paper experiments","text":"cd scripts\njulia","category":"page"},{"location":"paper/","page":"Reproducing paper experiments","title":"Reproducing paper experiments","text":"Enter pkg mode by typing ]","category":"page"},{"location":"paper/","page":"Reproducing paper experiments","title":"Reproducing paper experiments","text":"pkg> activate .\n(scripts) pkg> instantiate","category":"page"},{"location":"paper/","page":"Reproducing paper experiments","title":"Reproducing paper experiments","text":"You you have Gurobi installed, you can also add the corresponding package and import it:","category":"page"},{"location":"paper/","page":"Reproducing paper experiments","title":"Reproducing paper experiments","text":"(scripts) pkg> add Gurobi\njulia> using Gurobi","category":"page"},{"location":"paper/#.-Generate-datasets","page":"Reproducing paper experiments","title":"1. Generate datasets","text":"","category":"section"},{"location":"paper/","page":"Reproducing paper experiments","title":"Reproducing paper experiments","text":"The first script is 01_dataset.jl, which generate all the datasets needed for the experiments. You can change the settings variable if you want to create different datasets.","category":"page"},{"location":"paper/#.-Train-models","page":"Reproducing paper experiments","title":"2. Train models","text":"","category":"section"},{"location":"paper/","page":"Reproducing paper experiments","title":"Reproducing paper experiments","text":"The second script 02_training.jl is the main script, that runs all the trainings. It uses the config files in the configs folder. If you want to run different experiments, you can either modify the config files, or create new ones and add them to the script. By default, training results will be written in the logs directory.","category":"page"},{"location":"paper/#.-Visualize-training-plots","page":"Reproducing paper experiments","title":"3. Visualize training plots","text":"","category":"section"},{"location":"paper/","page":"Reproducing paper experiments","title":"Reproducing paper experiments","text":"In order to visualize training plot evolution there are two options:","category":"page"},{"location":"paper/","page":"Reproducing paper experiments","title":"Reproducing paper experiments","text":"Install tensorboard an run tensorboard --logdir=logs, which allow monitoring dynamically all the training plots during and after training.\nRun the 03_generate_plots.jl script to generate static plots after the training.","category":"page"},{"location":"paper/#.-Evaluate-final-models","page":"Reproducing paper experiments","title":"4. Evaluate final models","text":"","category":"section"},{"location":"paper/","page":"Reproducing paper experiments","title":"Reproducing paper experiments","text":"The 04_evaluate_model.jl script evaluates each of the models on all the test datasets. And write the results to logs/results","category":"page"},{"location":"paper/#.-Generate-result-tables","page":"Reproducing paper experiments","title":"5. Generate result tables","text":"","category":"section"},{"location":"paper/","page":"Reproducing paper experiments","title":"Reproducing paper experiments","text":"Finally, 05_generate_tables.jl reads from logs/results and creates readable tables in LaTeX format.","category":"page"},{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/#Index","page":"API Reference","title":"Index","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"","category":"page"},{"location":"api/#Reference","page":"API Reference","title":"Reference","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Modules = [StochasticVehicleScheduling]","category":"page"},{"location":"api/#StochasticVehicleScheduling.City","page":"API Reference","title":"StochasticVehicleScheduling.City","text":"City\n\nContains all the relevant information for an instance of the stochastic VSP problem.\n\nFields\n\nwidth::Int: city width (in minutes)\nvehicle_cost::Float64: cost of a vehicle in the objective function\ndelay_cost::Float64: cost of one minute delay in the objective function\nnb_tasks::Int: number of tasks to fulfill\ntasks::Vector{Task}: tasks list (see Task), that should be ordered by start time\ndistrict_width::Int: width (in minutes) of each district\ndistricts::Matrix{District}: districts matrix (see District),   indices corresponding to their relative positions\nrandom_inter_area_factor::LogNormal{Float64}: a log-normal distribution modeling delay   between districts\nscenario_inter_area_factor::Matrix{Float64}: size (nb_scenarios, 24),   each row correspond to one scenario, each column to one hour of the day\n\n\n\n\n\n","category":"type"},{"location":"api/#StochasticVehicleScheduling.CompactInstance","page":"API Reference","title":"StochasticVehicleScheduling.CompactInstance","text":"CompactInstance{G<:AbstractGraph,M1,M2,C}\n\nInstance of the stochastic VSP problem.\n\nFields\n\ngraph::G: graph computed from city with the create_VSP_graph(city::City) method.\nfeatures::Matrix{Float64}: features matrix computed from city\nslacks\ndelays\n\n\n\n\n\n","category":"type"},{"location":"api/#StochasticVehicleScheduling.CompactInstance-Tuple{StochasticVehicleScheduling.City}","page":"API Reference","title":"StochasticVehicleScheduling.CompactInstance","text":"CompactInstance(city::City)\n\nBuild a CompactInstance from a City, by computing its graph, features, slacks and delays.\n\n\n\n\n\n","category":"method"},{"location":"api/#StochasticVehicleScheduling.District","page":"API Reference","title":"StochasticVehicleScheduling.District","text":"District\n\nFields\n\nrandom_delay::LogNormal{Float64}: log-normal distribution modeling the district delay\nscenario_delay::Matrix{Float64}: size (nb_scenarios, 24),   observed delays for each scenario and hour of the day\n\n\n\n\n\n","category":"type"},{"location":"api/#StochasticVehicleScheduling.District-Tuple{}","page":"API Reference","title":"StochasticVehicleScheduling.District","text":"District(; random_delay::LogNormal{Float64}, nb_scenarios::Int)\n\nInitialize a district with a given number of scenarios, with zeros in scenario_delay.\n\n\n\n\n\n","category":"method"},{"location":"api/#StochasticVehicleScheduling.Instance","page":"API Reference","title":"StochasticVehicleScheduling.Instance","text":"Instance{G<:AbstractGraph,M1,M2,C}\n\nInstance of the stochastic VSP problem.\n\nFields\n\ncity::City\ngraph::G: graph computed from city with the create_VSP_graph(city::City) method.\nfeatures::Matrix{Float64}: features matrix computed from city\nslacks\ndelays\n\n\n\n\n\n","category":"type"},{"location":"api/#StochasticVehicleScheduling.Instance-Tuple{StochasticVehicleScheduling.City}","page":"API Reference","title":"StochasticVehicleScheduling.Instance","text":"Instance(city::City)\n\nBuild an Instance from a City, by computing its graph, features, slacks and delays.\n\n\n\n\n\n","category":"method"},{"location":"api/#StochasticVehicleScheduling.Pipeline","page":"API Reference","title":"StochasticVehicleScheduling.Pipeline","text":"Pipeline\n\nInferOpt pipeline container an encoder and a maximizer\n\n\n\n\n\n","category":"type"},{"location":"api/#StochasticVehicleScheduling.Solution","page":"API Reference","title":"StochasticVehicleScheduling.Solution","text":"Solution\n\nShould always be associated with an Instance.\n\nFields\n\nvalue::BitVector: for each graph edge of instance, 1 if selected, else 0\npath_value::BitMatrix: each row represents a vehicle, each column a task.   1 if task is done by the vehicle, else 0\n\n\n\n\n\n","category":"type"},{"location":"api/#StochasticVehicleScheduling.Solution-Tuple{BitMatrix, StochasticVehicleScheduling.AbstractInstance}","page":"API Reference","title":"StochasticVehicleScheduling.Solution","text":"Solution(value::BitVector, instance::AbstractInstance)\n\nCreate a Solution from a BitMatrix path value.\n\n\n\n\n\n","category":"method"},{"location":"api/#StochasticVehicleScheduling.Solution-Tuple{BitVector, StochasticVehicleScheduling.AbstractInstance}","page":"API Reference","title":"StochasticVehicleScheduling.Solution","text":"Solution(value::BitVector, instance::AbstractInstance)\n\nCreate a Solution from a BitVector value.\n\n\n\n\n\n","category":"method"},{"location":"api/#StochasticVehicleScheduling.Task","page":"API Reference","title":"StochasticVehicleScheduling.Task","text":"Task\n\nFields\n\ntype::TaskType\nstart_point::Point: starting location of the task\nend_point::Point: end location of the task\nstart_time::Float64: start time (in minutes) of the task\nend_time::Float64: end time (in minutes) of the task\nrandom_delay::LogNormal{Float64}: lognormal distribution modeling the task start delay\nscenario_start_time::Vector{Float64}: size (nb_scenarios),   realized delayed start times for each scenario\nscenario_end_time::Vector{Float64}: size (nb_scenarios),   realized delayed end times for each scenario\n\n\n\n\n\n","category":"type"},{"location":"api/#StochasticVehicleScheduling.Trainer","page":"API Reference","title":"StochasticVehicleScheduling.Trainer","text":"Trainer\n\nMain structure used for training an InferOpt model.\n\n\n\n\n\n","category":"type"},{"location":"api/#StochasticVehicleScheduling.basic_solution-Tuple{StochasticVehicleScheduling.AbstractInstance}","page":"API Reference","title":"StochasticVehicleScheduling.basic_solution","text":"basic_solution(graph::AbstractGraph)\n\nCreate a solution with one vehicle per task.\n\n\n\n\n\n","category":"method"},{"location":"api/#StochasticVehicleScheduling.cbc_model-Tuple{}","page":"API Reference","title":"StochasticVehicleScheduling.cbc_model","text":"cbc_model()\n\nInitialiaze a Cbc model with disabled logging.\n\n\n\n\n\n","category":"method"},{"location":"api/#StochasticVehicleScheduling.column_generation-Tuple{StochasticVehicleScheduling.AbstractInstance}","page":"API Reference","title":"StochasticVehicleScheduling.column_generation","text":"column_generation(instance::Instance)\n\nNote: If you have Gurobi, use grb_model as model_builder instead of glpk_model.\n\n\n\n\n\n","category":"method"},{"location":"api/#StochasticVehicleScheduling.compute_delays-Tuple{StochasticVehicleScheduling.City}","page":"API Reference","title":"StochasticVehicleScheduling.compute_delays","text":"compute_delays(city)\n\nCompute delays for instance.\n\n\n\n\n\n","category":"method"},{"location":"api/#StochasticVehicleScheduling.compute_features-Tuple{StochasticVehicleScheduling.City}","page":"API Reference","title":"StochasticVehicleScheduling.compute_features","text":"compute_features(city::City)\n\nReturns a matrix of features of size (20, nb_edges). For each edge, compute the following features (in the same order):\n\ntravel time\nvehicle_cost if edge is connected to source, else 0\n9 deciles of the slack\ncumulative probability distribution of the slack evaluated in [-100, -50, -20, -10, 0, 10, 50, 200, 500]\n\n\n\n\n\n","category":"method"},{"location":"api/#StochasticVehicleScheduling.compute_slacks-Tuple{StochasticVehicleScheduling.City, Graphs.AbstractGraph}","page":"API Reference","title":"StochasticVehicleScheduling.compute_slacks","text":"compute_slacks(city)\n\nCompute slack for instance. TODO: differentiate from other method\n\n\n\n\n\n","category":"method"},{"location":"api/#StochasticVehicleScheduling.compute_slacks-Tuple{StochasticVehicleScheduling.City, Int64, Int64}","page":"API Reference","title":"StochasticVehicleScheduling.compute_slacks","text":"compute_slacks(city, old_task_index, new_task_index)\n\nCompute slack for features.\n\n\n\n\n\n","category":"method"},{"location":"api/#StochasticVehicleScheduling.compute_solution_from_selected_columns-Tuple{StochasticVehicleScheduling.AbstractInstance, Any}","page":"API Reference","title":"StochasticVehicleScheduling.compute_solution_from_selected_columns","text":"compute_solution_from_selected_columns(instance::AbstractInstance, paths[; bin=true])\n\nNote: If you have Gurobi, use grb_model as model_builder instead od glpk_model.\n\n\n\n\n\n","category":"method"},{"location":"api/#StochasticVehicleScheduling.compute_μ_σ-Tuple{Vector{<:StochasticVehicleScheduling.AbstractInstance}}","page":"API Reference","title":"StochasticVehicleScheduling.compute_μ_σ","text":"compute_μ_σ(X::Vector{Instance})\n\nCompute mean, standard deviation, and max values for each features in X instances.\n\n\n\n\n\n","category":"method"},{"location":"api/#StochasticVehicleScheduling.create_VSP_graph-Tuple{StochasticVehicleScheduling.City}","page":"API Reference","title":"StochasticVehicleScheduling.create_VSP_graph","text":"create_VSP_graph(city::City)\n\nReturn a MetaDiGraph computed from city. Each vertex represents a task. Vertices are ordered by start time of corresponding task. There is an edge from task u to task v the (end time of u + tie distance between u and v <= start time of v). Every (u, v) edge has a :travel_time property, corresponding to time istance between u and v.\n\n\n\n\n\n","category":"method"},{"location":"api/#StochasticVehicleScheduling.create_random_city-Tuple{}","page":"API Reference","title":"StochasticVehicleScheduling.create_random_city","text":"create_random_city(;\n    αᵥ_low=default_αᵥ_low,\n    αᵥ_high=default_αᵥ_high,\n    first_begin_time=default_first_begin_time,\n    last_begin_time=default_last_begin_time,\n    district_μ=default_district_μ,\n    district_σ=default_district_σ,\n    task_μ=default_task_μ,\n    task_σ=default_task_σ,\n    city_kwargs...\n)\n\nCreate a city from city_kwargs\nDepot location at city center\nRandomize tasks, and add two dummy tasks : one source task at time=0 from the depot,   and one destination task ending at time=end at depot\nRoll every scenario.\n\n\n\n\n\n","category":"method"},{"location":"api/#StochasticVehicleScheduling.create_random_compact_instance-Tuple{}","page":"API Reference","title":"StochasticVehicleScheduling.create_random_compact_instance","text":"create_random_instance([; city_kwargs])\n\nReturns a random instance created with city_kwargs.\n\n\n\n\n\n","category":"method"},{"location":"api/#StochasticVehicleScheduling.create_random_instance-Tuple{}","page":"API Reference","title":"StochasticVehicleScheduling.create_random_instance","text":"create_random_instance([; city_kwargs])\n\nReturns a random instance created with city_kwargs.\n\n\n\n\n\n","category":"method"},{"location":"api/#StochasticVehicleScheduling.delay_sum-Tuple{Any, Any, Any}","page":"API Reference","title":"StochasticVehicleScheduling.delay_sum","text":"delay_sum(path, slacks, delays)\n\nEvaluate the total delay along path.\n\n\n\n\n\n","category":"method"},{"location":"api/#StochasticVehicleScheduling.distance-Tuple{StochasticVehicleScheduling.Point, StochasticVehicleScheduling.Point}","page":"API Reference","title":"StochasticVehicleScheduling.distance","text":"distance(p₁, p₂)\n\nReturns euclidean distance between p₁ and p₂.\n\n\n\n\n\n","category":"method"},{"location":"api/#StochasticVehicleScheduling.draw_random_point-Tuple{Distributions.Distribution}","page":"API Reference","title":"StochasticVehicleScheduling.draw_random_point","text":"draw_random_point(distrib)\n\nReturns a Point with random x and y, drawn from distrib.\n\n\n\n\n\n","category":"method"},{"location":"api/#StochasticVehicleScheduling.easy_problem-Tuple{AbstractVector}","page":"API Reference","title":"StochasticVehicleScheduling.easy_problem","text":"easy_problem(θ[; instance::AbstractInstance, model_builder])\n\nSolves the easy problem of the learning pipeline given arcs weights θ. Note: If you have Gurobi, use grb_model as model_builder instead od cbc_model.\n\n\n\n\n\n","category":"method"},{"location":"api/#StochasticVehicleScheduling.evaluate_scenario-Tuple{BitMatrix, StochasticVehicleScheduling.AbstractInstance, Int64}","page":"API Reference","title":"StochasticVehicleScheduling.evaluate_scenario","text":"evaluate_scenario(path_value::BitMatrix, instance::AbstractInstance, scenario_index::Int)\n\nCompute total delay of scenario.\n\n\n\n\n\n","category":"method"},{"location":"api/#StochasticVehicleScheduling.evaluate_scenario-Tuple{Solution, StochasticVehicleScheduling.AbstractInstance, Int64}","page":"API Reference","title":"StochasticVehicleScheduling.evaluate_scenario","text":"evaluate_scenario(solution::Solution, instance::AbstractInstance, scenario_index::Int)\n\nCompute total delay of scenario.\n\n\n\n\n\n","category":"method"},{"location":"api/#StochasticVehicleScheduling.evaluate_solution-Tuple{BitMatrix, StochasticVehicleScheduling.AbstractInstance}","page":"API Reference","title":"StochasticVehicleScheduling.evaluate_solution","text":"evaluate_scenario(path_value::BitMatrix, instance::AbstractInstance, scenario_index::Int)\n\nCompute total weighted objective of solution.\n\n\n\n\n\n","category":"method"},{"location":"api/#StochasticVehicleScheduling.evaluate_solution-Tuple{Solution, StochasticVehicleScheduling.AbstractInstance}","page":"API Reference","title":"StochasticVehicleScheduling.evaluate_solution","text":"evaluate_scenario(path_value::BitMatrix, instance::AbstractInstance, scenario_index::Int)\n\nCompute total weighted objective of solution.\n\n\n\n\n\n","category":"method"},{"location":"api/#StochasticVehicleScheduling.evaluate_task-Tuple{Integer, StochasticVehicleScheduling.AbstractInstance, Integer, Real, Int64}","page":"API Reference","title":"StochasticVehicleScheduling.evaluate_task","text":"evaluate_task(\n    i_task::Integer,\n    instance::AbstractInstance,\n    old_task_index::Integer,\n    old_delay::Real,\n    scenario::Int,\n)\n\nEvaluate the total delay of task i_task in scenario, knowing that current delay from task old_task_index is old_delay.\n\n\n\n\n\n","category":"method"},{"location":"api/#StochasticVehicleScheduling.find_first_one-Tuple{AbstractVector}","page":"API Reference","title":"StochasticVehicleScheduling.find_first_one","text":"find_first_one(A)\n\nReturns index of first non zero element of A.\n\n\n\n\n\n","category":"method"},{"location":"api/#StochasticVehicleScheduling.generate_dataset-Tuple{String, Integer, Integer, Integer}","page":"API Reference","title":"StochasticVehicleScheduling.generate_dataset","text":"generate_dataset(\n    dataset_folder::String,\n    nb_train_samples::Integer,\n    nb_val_samples::Integer,\n    nb_test_samples::Integer;\n    random_seed=67,\n    labeled=true,\n    heuristic=true,\n    city_kwargs,\n)\n\nCreate a dataset in dataset_folder, train/validation/test samples, one file per subdataset. Also create a config file in the same location with some information.\n\n\n\n\n\n","category":"method"},{"location":"api/#StochasticVehicleScheduling.generate_samples-Tuple{Integer}","page":"API Reference","title":"StochasticVehicleScheduling.generate_samples","text":"generate_samples(nb_samples::Integer[; heuristic=true, labeled=true, city_kwargs])\n\nGenerate nb_samples random instances with city_kwargs. If labeled, compute associated solutions for each instance: use local search if heuristic, else compute optimal solution.\n\n\n\n\n\n","category":"method"},{"location":"api/#StochasticVehicleScheduling.get_district-Tuple{StochasticVehicleScheduling.Point, StochasticVehicleScheduling.City}","page":"API Reference","title":"StochasticVehicleScheduling.get_district","text":"get_district(point::Point, city::City)\n\nReturn indices of the city district containing point.\n\n\n\n\n\n","category":"method"},{"location":"api/#StochasticVehicleScheduling.get_nb_scenarios-Tuple{StochasticVehicleScheduling.AbstractInstance}","page":"API Reference","title":"StochasticVehicleScheduling.get_nb_scenarios","text":"get_nb_scenarios(instance::AbstractInstance)\n\nReturns the number of scenarios in instance.\n\n\n\n\n\n","category":"method"},{"location":"api/#StochasticVehicleScheduling.get_nb_scenarios-Tuple{StochasticVehicleScheduling.City}","page":"API Reference","title":"StochasticVehicleScheduling.get_nb_scenarios","text":"get_nb_scenarios(city::City)\n\nReturns the number of scenarios in city.\n\n\n\n\n\n","category":"method"},{"location":"api/#StochasticVehicleScheduling.get_nb_tasks-Tuple{StochasticVehicleScheduling.AbstractInstance}","page":"API Reference","title":"StochasticVehicleScheduling.get_nb_tasks","text":"get_nb_tasks(instance::AbstractInstance)\n\nReturns the number of tasks in instance.\n\n\n\n\n\n","category":"method"},{"location":"api/#StochasticVehicleScheduling.get_nb_tasks-Tuple{StochasticVehicleScheduling.City}","page":"API Reference","title":"StochasticVehicleScheduling.get_nb_tasks","text":"get_nb_tasks(city::City)\n\nReturns the number of tasks in city.\n\n\n\n\n\n","category":"method"},{"location":"api/#StochasticVehicleScheduling.get_perturbed_travel_time-Tuple{StochasticVehicleScheduling.City, Int64, Int64, Int64}","page":"API Reference","title":"StochasticVehicleScheduling.get_perturbed_travel_time","text":"get_perturbed_travel_time(city::City, old_task_index::Int, new_task_index::Int, scenario::Int)\n\nCompute the achieved travel time of scenario scenario from old_task_index to new_task_index.\n\n\n\n\n\n","category":"method"},{"location":"api/#StochasticVehicleScheduling.get_routes-Tuple{Solution}","page":"API Reference","title":"StochasticVehicleScheduling.get_routes","text":"get_routes(solution::Solution)\n\nCompute routes of solution.\n\n\n\n\n\n","category":"method"},{"location":"api/#StochasticVehicleScheduling.glpk_model-Tuple{}","page":"API Reference","title":"StochasticVehicleScheduling.glpk_model","text":"glpk_model()\n\nInitialize a GLPK model (with disabled logging).\n\n\n\n\n\n","category":"method"},{"location":"api/#StochasticVehicleScheduling.heuristic_solution-Tuple{StochasticVehicleScheduling.AbstractInstance}","page":"API Reference","title":"StochasticVehicleScheduling.heuristic_solution","text":"heuristic_solution(instance::AbstractInstance; nb_it=100)\n\nVery simple heuristic, using local_search     initialised with the solution of the deterministic Linear program\n\n\n\n\n\n","category":"method"},{"location":"api/#StochasticVehicleScheduling.highs_model-Tuple{}","page":"API Reference","title":"StochasticVehicleScheduling.highs_model","text":"highs_model()\n\nInitialize a HiGHS model (with disabled logging).\n\n\n\n\n\n","category":"method"},{"location":"api/#StochasticVehicleScheduling.hour_of-Tuple{Real}","page":"API Reference","title":"StochasticVehicleScheduling.hour_of","text":"hour_of(minutes::Real)::Int\n\nReturns hour of the day corresponding to minutes amount.\n\n\n\n\n\n","category":"method"},{"location":"api/#StochasticVehicleScheduling.is_admissible-Tuple{Solution, StochasticVehicleScheduling.AbstractInstance}","page":"API Reference","title":"StochasticVehicleScheduling.is_admissible","text":"is_admissible(solution::Solution, instance::AbstractInstance)\n\nCheck if solution is an admissible solution of instance.\n\n\n\n\n\n","category":"method"},{"location":"api/#StochasticVehicleScheduling.local_search-Tuple{Solution, StochasticVehicleScheduling.AbstractInstance}","page":"API Reference","title":"StochasticVehicleScheduling.local_search","text":"local_search(solution::Solution, instance::AbstractInstance; nb_it::Integer=100)\n\nVery simple local search heuristic, using the neighborhood defined by move_one_random_task\n\n\n\n\n\n","category":"method"},{"location":"api/#StochasticVehicleScheduling.move_one_random_task!-Tuple{BitMatrix, Graphs.AbstractGraph}","page":"API Reference","title":"StochasticVehicleScheduling.move_one_random_task!","text":"move_one_random_task!(path_value::BitMatrix, graph::AbstractGraph)\n\nSelect one random (uniform) task and move it to another random (uniform) feasible vehicle\n\n\n\n\n\n","category":"method"},{"location":"api/#StochasticVehicleScheduling.normalize_data!-Tuple{Any, Any, Any}","page":"API Reference","title":"StochasticVehicleScheduling.normalize_data!","text":"normalize_data!(X, μ, σ)\n\nStandardize each feature of X by centering and reducing with μ and σ.\n\n\n\n\n\n","category":"method"},{"location":"api/#StochasticVehicleScheduling.read_config-Tuple{String}","page":"API Reference","title":"StochasticVehicleScheduling.read_config","text":"read_config(config_file::String)\n\nRead a Yaml config into a NamedTuple.\n\n\n\n\n\n","category":"method"},{"location":"api/#StochasticVehicleScheduling.recursive_convert-Tuple{Any}","page":"API Reference","title":"StochasticVehicleScheduling.recursive_convert","text":"recursive_convert(x)\n\nConvert recursively a NamedTuple to a Dict.\n\n\n\n\n\n","category":"method"},{"location":"api/#StochasticVehicleScheduling.recursive_namedtuple-Tuple{Any}","page":"API Reference","title":"StochasticVehicleScheduling.recursive_namedtuple","text":"recursive_namedtuple(x)\n\nConvert recursively a Dict to a NamedTuple.\n\n\n\n\n\n","category":"method"},{"location":"api/#StochasticVehicleScheduling.reduce_data!-Tuple{Any, Any}","page":"API Reference","title":"StochasticVehicleScheduling.reduce_data!","text":"reduce_data!(X, σ)\n\nReduce X with σ, without centering it.\n\n\n\n\n\n","category":"method"},{"location":"api/#StochasticVehicleScheduling.roll-Tuple{StochasticVehicleScheduling.District}","page":"API Reference","title":"StochasticVehicleScheduling.roll","text":"roll(task)\n\nPopulate scenario_delay with delays drawn from random_delay distribution for each (scenario, hour) pair.\n\n\n\n\n\n","category":"method"},{"location":"api/#StochasticVehicleScheduling.roll-Tuple{StochasticVehicleScheduling.Task}","page":"API Reference","title":"StochasticVehicleScheduling.roll","text":"roll(task)\n\nPopulate scenario_start_time with delays drawn from random_delay distribution for each scenario.\n\n\n\n\n\n","category":"method"},{"location":"api/#StochasticVehicleScheduling.save_config-Tuple{Dict, String}","page":"API Reference","title":"StochasticVehicleScheduling.save_config","text":"save_config(config::Dict, save_path::String)\n\nSave Dict config to yaml file.\n\n\n\n\n\n","category":"method"},{"location":"api/#StochasticVehicleScheduling.save_config-Tuple{NamedTuple, String}","page":"API Reference","title":"StochasticVehicleScheduling.save_config","text":"save_config(config::NamedTuple, save_path::String)\n\nSave a NamedTuple config to yaml file.\n\n\n\n\n\n","category":"method"},{"location":"api/#StochasticVehicleScheduling.scenario_next_delay-Tuple{Real, Distributions.Distribution}","page":"API Reference","title":"StochasticVehicleScheduling.scenario_next_delay","text":"scenario_next_delay(previous_delay, random_delay)\n\nReturn one scenario of future delay given current delay and delay distribution.\n\n\n\n\n\n","category":"method"},{"location":"api/#StochasticVehicleScheduling.solution_from_JuMP_array-Tuple{AbstractArray, Graphs.AbstractGraph}","page":"API Reference","title":"StochasticVehicleScheduling.solution_from_JuMP_array","text":"solution_from_paths(paths, instance::AbstractInstance)\n\nCreate a Solution from a JuMP array.\n\n\n\n\n\n","category":"method"},{"location":"api/#StochasticVehicleScheduling.solution_from_paths-Tuple{Any, StochasticVehicleScheduling.AbstractInstance}","page":"API Reference","title":"StochasticVehicleScheduling.solution_from_paths","text":"solution_from_paths(paths, instance::AbstractInstance)\n\nCreate a Solution from routes.\n\n\n\n\n\n","category":"method"},{"location":"api/#StochasticVehicleScheduling.solve_deterministic_VSP-Tuple{Instance}","page":"API Reference","title":"StochasticVehicleScheduling.solve_deterministic_VSP","text":"solve_deterministic_VSP(instance::Instance; include_delays=true)\n\nReturn the optimal solution of the deterministic VSP problem associated to instance. The objective function is vehicle_cost * nb_vehicles + include_delays * delay_cost * sum_of_travel_times Note: If you have Gurobi, use grb_model as model_builder instead od cbc_model.\n\n\n\n\n\n","category":"method"},{"location":"api/#StochasticVehicleScheduling.solve_scenarios-Tuple{StochasticVehicleScheduling.AbstractInstance}","page":"API Reference","title":"StochasticVehicleScheduling.solve_scenarios","text":"solve_scenarios(instance::AbstractInstance; model_builder)\n\nReturns the optimal solution of the Stochastic VSP instance, by solving the associated MIP. Note: If you have Gurobi, use grb_model as model_builder instead od cbc_model.\n\n\n\n\n\n","category":"method"},{"location":"api/#StochasticVehicleScheduling.to_array-Tuple{Solution, StochasticVehicleScheduling.AbstractInstance}","page":"API Reference","title":"StochasticVehicleScheduling.to_array","text":"to_array(solution::Solution, instance::AbstractInstance)\n\nReturns a BitMatrix, with value true at each index (i, j) if corresponding edge of graph is selected in the solution\n\n\n\n\n\n","category":"method"},{"location":"math/#Problem-statement","page":"Problem statement","title":"Problem statement","text":"","category":"section"},{"location":"math/#Deterministic-Vehicle-Scheduling","page":"Problem statement","title":"Deterministic Vehicle Scheduling","text":"","category":"section"},{"location":"math/","page":"Problem statement","title":"Problem statement","text":"The Vehicle Scheduling Problem (VSP) consists in assigning vehicles to cover a set of scheduled tasks, while minimizing total costs. Let bar V be the set of tasks. Each task vin bar V has a scheduled beginning time t_v^b, and a scheduled end time t_v^e, such that t_v^e  t_v^b. We denote t^tr_(u v) the travel time from task u to task v. A task v can be scheduled after another task u only if we can reach it in time, before it starts, i.e. if","category":"page"},{"location":"math/","page":"Problem statement","title":"Problem statement","text":"t_v^b geq t_u^e + t^tr_(u v)","category":"page"},{"location":"math/","page":"Problem statement","title":"Problem statement","text":"An instance of VSP can be modeled with a directed graph D = (V A), with V = bar Vcupo d, and o, d origin and destination dummy nodes. All tasks are connected to o, and d is connected to all tasks. There is an arc between two tasks u and v only if the equation above is satisfied. The resulting graph D is acyclic. For all arc ain A, we denote theta_a the cost of using a.","category":"page"},{"location":"math/","page":"Problem statement","title":"Problem statement","text":"A solution of the VSP problem is a list of disjoint o-d paths such that all tasks are fulfilled exactly once. The objective is to minimize the total cost. This can be formulated as the following Linear Program:","category":"page"},{"location":"math/","page":"Problem statement","title":"Problem statement","text":"beginaligned\nmin   sum_ain delta^+(o) y_a \nst  sum_ain delta^-(v) y_a = sum_ain delta^+(v) y_a  forall v in bar V\n sum_ain delta^-(v) y_a = 1  forall v in bar V\n (y_a in 0 1) forall ain A\nendaligned","category":"page"},{"location":"math/","page":"Problem statement","title":"Problem statement","text":"The constraints matrix being totally unimodular, integrity constraints can be dropped and the problem can be solved using a linear solver.","category":"page"},{"location":"math/","page":"Problem statement","title":"Problem statement","text":"","category":"page"},{"location":"math/#Stochastic-Vehicle-Scheduling","page":"Problem statement","title":"Stochastic Vehicle Scheduling","text":"","category":"section"},{"location":"math/","page":"Problem statement","title":"Problem statement","text":"In the Stochastic Vehicle Scheduling Problem (StoVSP), we consider the same setting as the deterministic version, to which we add the following. Once the scheduling decision is set, we observe random delays, which propagate along vehicle tours. The objective is to minimize the sum of vehicle costs and expected total delay costs.","category":"page"},{"location":"math/","page":"Problem statement","title":"Problem statement","text":"We consider a finite set of scenarios sin S. For each task vin bar V, we denote gamma_v^s the intrinsic delay of v in scenario s, and d_v^s its total delay. We also denote delta_u v^s the slack between tasks u and v. These quantities follow the delay propagation equation when u and v are consecutively operated by the same vehicle:","category":"page"},{"location":"math/","page":"Problem statement","title":"Problem statement","text":"d_v^s = gamma_v^s + max(d_u^s - delta_u v^s 0)","category":"page"},{"location":"math/","page":"Problem statement","title":"Problem statement","text":"This leads to a much more difficult problem to solve. If the instance isn't too big, we can solve it using an integer program with quadratic constraints or a column generation algorithm.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = StochasticVehicleScheduling","category":"page"},{"location":"#StochasticVehicleScheduling","page":"Home","title":"StochasticVehicleScheduling","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for StochasticVehicleScheduling. This package is a satellite of InferOpt.jl. It illustrates Machine Learning/Combinatorial Optimization hybrid algorithms from InferOpt.jl applied to the Stochastic Vehicle Scheduling problem. It was used for one of the numerical experiments in this paper: https://arxiv.org/abs/2207.13513","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you have any feedback or question, feel free to create an issue or contact me.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(url=\"https://github.com/BatyLeo/StochasticVehicleScheduling.jl\")","category":"page"},{"location":"#Table-of-contents","page":"Home","title":"Table of contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Problem statement\nInstance generator\nOptimization algorithms\nLearning using InferOpt.jl\nInferOpt tutorial\nReproducing paper experiments from https://arxiv.org/abs/2207.13513","category":"page"},{"location":"inferopt/","page":"InferOpt tutorial","title":"InferOpt tutorial","text":"EditURL = \"https://github.com/BatyLeo/StochasticVehicleScheduling.jl/blob/main/docs/src/literate/inferopt.jl\"","category":"page"},{"location":"inferopt/#InferOpt-tutorial","page":"InferOpt tutorial","title":"InferOpt tutorial","text":"","category":"section"},{"location":"inferopt/","page":"InferOpt tutorial","title":"InferOpt tutorial","text":"In this tutorial, we will use hybrid methods between Machine Learning (ML) and Combinatorial Optimization (CO) from the package InferOpt.jl. The goal is to learn to approximate a hard problem (Stochastic Vehicle Scheduling Problem) by an easier one (Vehicle Scheduling Problem). For more details, you can look at the InferOpt.jl documentation, or its corresponding paper.","category":"page"},{"location":"inferopt/","page":"InferOpt tutorial","title":"InferOpt tutorial","text":"# Imports useful packages and fix seed\nusing Flux\nusing Plots\nusing InferOpt\nusing Random\nusing Statistics: mean\nusing StochasticVehicleScheduling\nRandom.seed!(1);\nnothing #hide","category":"page"},{"location":"inferopt/#Introduction","page":"InferOpt tutorial","title":"Introduction","text":"","category":"section"},{"location":"inferopt/","page":"InferOpt tutorial","title":"InferOpt tutorial","text":"Let instance be an instance of the Stochastic Vehicle Scheduling problem, and D = (V A) its associated graph. For each arc ain A, we compute a features vector x_ain mathbbR^n. We obtain a feature matrix XinmathbbR^ntimes A. For more details about the features computation, see Features.","category":"page"},{"location":"inferopt/","page":"InferOpt tutorial","title":"InferOpt tutorial","text":"nb_tasks = 10\nnb_scenarios = 10\ninstance = create_random_instance(; nb_tasks, nb_scenarios)\n@info \"Example instance\" instance.graph instance.features","category":"page"},{"location":"inferopt/","page":"InferOpt tutorial","title":"InferOpt tutorial","text":"Let winmathbbR^n a weight vector. We define the following Generalized Linear Model (GLM) varphi_w, that let us compute arcs weights theta_ain mathcal R for each arc ain A.","category":"page"},{"location":"inferopt/","page":"InferOpt tutorial","title":"InferOpt tutorial","text":"theta_a = varphi_w(x_a) = w^top x_a","category":"page"},{"location":"inferopt/","page":"InferOpt tutorial","title":"InferOpt tutorial","text":"nb_features = size(instance.features, 1)\nφ_w = Chain(Dense(nb_features => 1; bias=false), vec)  # Note: we use methods from Flux to build the GLM, w is initialized randomly by default","category":"page"},{"location":"inferopt/","page":"InferOpt tutorial","title":"InferOpt tutorial","text":"We can use the GLM to compute arcs weights θ","category":"page"},{"location":"inferopt/","page":"InferOpt tutorial","title":"InferOpt tutorial","text":"θ = φ_w(instance.features)\nθ'","category":"page"},{"location":"inferopt/","page":"InferOpt tutorial","title":"InferOpt tutorial","text":"Then, we define what we call the easy problem as the following linear program:","category":"page"},{"location":"inferopt/","page":"InferOpt tutorial","title":"InferOpt tutorial","text":"beginaligned\ny = argmax_y  sum_ain A theta_a y_a \nst  sum_ain delta^-(v) y_a = sum_ain delta^+(v) y_a  forall v in Vbackslash o d\n sum_ain delta^-(v) y_a = 1  forall v in Vbackslash o d\n y_a in 0 1 forall ain A\nendaligned","category":"page"},{"location":"inferopt/","page":"InferOpt tutorial","title":"InferOpt tutorial","text":"Integrity contraints can be dropped because we have a flow polytope. Therefore, the easy problem can be solved easily, which is done by the easy_problem method (note: we need to give instance as input because we need to know the graph in order to build the constraints).","category":"page"},{"location":"inferopt/","page":"InferOpt tutorial","title":"InferOpt tutorial","text":"By applying it to arcs weights theta, we obtain the optimal solution y of the easy problem, which is also a feasible solution of the initial stochastic vehicle scheduling instance:","category":"page"},{"location":"inferopt/","page":"InferOpt tutorial","title":"InferOpt tutorial","text":"y = easy_problem(θ; instance=instance)\ny'","category":"page"},{"location":"inferopt/","page":"InferOpt tutorial","title":"InferOpt tutorial","text":"Let's evaluate it:","category":"page"},{"location":"inferopt/","page":"InferOpt tutorial","title":"InferOpt tutorial","text":"evaluate_solution(y, instance)","category":"page"},{"location":"inferopt/","page":"InferOpt tutorial","title":"InferOpt tutorial","text":"The objective value does not seem very good. Let's compare it to the value of the optimal solution of instance, using the exact algorrithm described in MIP formulation:","category":"page"},{"location":"inferopt/","page":"InferOpt tutorial","title":"InferOpt tutorial","text":"_, y_opt = solve_scenarios(instance)\nevaluate_solution(y_opt, instance)","category":"page"},{"location":"inferopt/","page":"InferOpt tutorial","title":"InferOpt tutorial","text":"This is not good, our prediction is far off the optimal solution 😟","category":"page"},{"location":"inferopt/","page":"InferOpt tutorial","title":"InferOpt tutorial","text":"Can we do better? Is it possible to find w that predicts theta that gives good solutions ?","category":"page"},{"location":"inferopt/","page":"InferOpt tutorial","title":"InferOpt tutorial","text":"The answer is yes, we can use tools from InferOpt in order to learn parameters w that yield good solutions for any instance.","category":"page"},{"location":"inferopt/","page":"InferOpt tutorial","title":"InferOpt tutorial","text":"First of all, let's assemble together our full pipeline:","category":"page"},{"location":"inferopt/","page":"InferOpt tutorial","title":"InferOpt tutorial","text":"xrightarrowtextInstanceX\nfboxEncoder varphi_w\nxrightarrowtextCost vectortheta in mathbbR^d(x)\nfboxEasy problem\nxrightarrowtextSolutiony in mathcalY(x)","category":"page"},{"location":"inferopt/","page":"InferOpt tutorial","title":"InferOpt tutorial","text":"pipeline(x) = easy_problem(φ_w(x.features); instance=x);\nnothing #hide","category":"page"},{"location":"inferopt/#Dataset-creation","page":"InferOpt tutorial","title":"Dataset creation","text":"","category":"section"},{"location":"inferopt/","page":"InferOpt tutorial","title":"InferOpt tutorial","text":"In order to learn something, we first need to create a dataset containing instances and corresponding solutions. We create a training dataset, and a validation dataset to evaluate the results.","category":"page"},{"location":"inferopt/","page":"InferOpt tutorial","title":"InferOpt tutorial","text":"nb_train_samples = 25\nnb_val_samples = 25\n\nX_train = [create_random_instance(; nb_tasks, nb_scenarios) for _ in 1:nb_train_samples]\nY_train = [solve_scenarios(x)[2] for x in X_train]\n\nX_val = [create_random_instance(; nb_tasks, nb_scenarios) for _ in 1:nb_val_samples]\nY_val = [solve_scenarios(x)[2] for x in X_val]\n\ndata_train, data_val = zip(X_train, Y_train), zip(X_val, Y_val);\nnothing #hide","category":"page"},{"location":"inferopt/","page":"InferOpt tutorial","title":"InferOpt tutorial","text":"We can evaluate our current pipeline by computing the average gap with the optimal solutions:","category":"page"},{"location":"inferopt/","page":"InferOpt tutorial","title":"InferOpt tutorial","text":"initial_pred = [pipeline(x) for x in X_val]\ninitial_obj = [evaluate_solution(y, x) for (x, y) in zip(X_val, initial_pred)]\nground_truth_obj = [evaluate_solution(y, x) for (x, y) in data_val]\n\ninitial_average_gap = mean((initial_obj .- ground_truth_obj) ./ ground_truth_obj .* 100)\n@info \"Initial gap ≃ $(round(initial_average_gap; digits=2))%\"","category":"page"},{"location":"inferopt/","page":"InferOpt tutorial","title":"InferOpt tutorial","text":"The gap very high, let's see if we can learn a good w that reduces it.","category":"page"},{"location":"inferopt/#Learning-by-imitation","page":"InferOpt tutorial","title":"Learning by imitation","text":"","category":"section"},{"location":"inferopt/#Regularization","page":"InferOpt tutorial","title":"Regularization","text":"","category":"section"},{"location":"inferopt/","page":"InferOpt tutorial","title":"InferOpt tutorial","text":"In order to train our model by using gradient descent, we need to be able to differentiate through easy_problem with automatic differenciation tools. The problem is that, as a combinatorial algorithm, it's pieciwise constant, therefore gradient descent won't work at all:","category":"page"},{"location":"inferopt/","page":"InferOpt tutorial","title":"InferOpt tutorial","text":"try\n    gradient(θ -> easy_problem(θ; instance=instance), θ)\ncatch e\n    @error e\nend","category":"page"},{"location":"inferopt/","page":"InferOpt tutorial","title":"InferOpt tutorial","text":"That's why we need to regularize the easy problem. Here we choose the PerturbedAdditive regularization from InferOpt.jl.","category":"page"},{"location":"inferopt/","page":"InferOpt tutorial","title":"InferOpt tutorial","text":"regularized_predictor = PerturbedAdditive(easy_problem; ε=0.1, nb_samples=10)","category":"page"},{"location":"inferopt/","page":"InferOpt tutorial","title":"InferOpt tutorial","text":"Instead of returning a binary solution, this wrapper around easy_problem takes the same inputs but returns a smooth a continuous solution.","category":"page"},{"location":"inferopt/","page":"InferOpt tutorial","title":"InferOpt tutorial","text":"y_pred = regularized_predictor(rand(length(θ)); instance=instance)\ny_pred[y_pred .>= 0.1 .&& y_pred .<= 0.9]'","category":"page"},{"location":"inferopt/#Loss-function","page":"InferOpt tutorial","title":"Loss function","text":"","category":"section"},{"location":"inferopt/","page":"InferOpt tutorial","title":"InferOpt tutorial","text":"We can now choose a differentiable loss function from InferOpt's toolbox. We choose a FenchelYoungLoss, that wraps our perturbed maximizer.","category":"page"},{"location":"inferopt/","page":"InferOpt tutorial","title":"InferOpt tutorial","text":"loss = FenchelYoungLoss(regularized_predictor)","category":"page"},{"location":"inferopt/","page":"InferOpt tutorial","title":"InferOpt tutorial","text":"We can evaluate our prediction theta respect to the optimal solution y_opt","category":"page"},{"location":"inferopt/","page":"InferOpt tutorial","title":"InferOpt tutorial","text":"loss(θ, y_opt.value; instance=instance)","category":"page"},{"location":"inferopt/","page":"InferOpt tutorial","title":"InferOpt tutorial","text":"And compute its gradient respect to theta","category":"page"},{"location":"inferopt/","page":"InferOpt tutorial","title":"InferOpt tutorial","text":"gradient(θ -> loss(θ, y_opt.value; instance=instance), θ)","category":"page"},{"location":"inferopt/","page":"InferOpt tutorial","title":"InferOpt tutorial","text":"We now have all the tools in order to learn our pipeline using gradient descent and automatic differentiation !","category":"page"},{"location":"inferopt/#Training-loop","page":"InferOpt tutorial","title":"Training loop","text":"","category":"section"},{"location":"inferopt/","page":"InferOpt tutorial","title":"InferOpt tutorial","text":"We train our model using the Flux.jl library, and tha Adam optimizer.","category":"page"},{"location":"inferopt/","page":"InferOpt tutorial","title":"InferOpt tutorial","text":"flux_loss(x, y) = loss(φ_w(x.features), y.value; instance=x)\n# Optimizer\nopt = Adam();\nnothing #hide","category":"page"},{"location":"inferopt/","page":"InferOpt tutorial","title":"InferOpt tutorial","text":"We train our model for 25 epochs","category":"page"},{"location":"inferopt/","page":"InferOpt tutorial","title":"InferOpt tutorial","text":"nb_epochs = 25\ntraining_losses, val_losses = Float64[], Float64[]\nobjective_gap_history = Float64[]\nfor _ in 1:nb_epochs\n    l = mean(flux_loss(x, y) for (x, y) in data_train)\n    l_test = mean(flux_loss(x, y) for (x, y) in data_val)\n    Y_pred = [pipeline(x) for x in X_val]\n    values = [evaluate_solution(y, x) for (x, y) in zip(X_val, Y_pred)]\n    V = mean((v_pred - v) / v * 100 for (v_pred, v) in zip(values, ground_truth_obj))\n    push!(training_losses, l)\n    push!(val_losses, l_test)\n    push!(objective_gap_history, V)\n\n    Flux.train!(flux_loss, Flux.params(φ_w), data_train, opt)\nend","category":"page"},{"location":"inferopt/#Results","page":"InferOpt tutorial","title":"Results","text":"","category":"section"},{"location":"inferopt/#Train-and-test-losses","page":"InferOpt tutorial","title":"Train and test losses","text":"","category":"section"},{"location":"inferopt/","page":"InferOpt tutorial","title":"InferOpt tutorial","text":"Let's check our pipeline performance, by plotting training and validation losses.","category":"page"},{"location":"inferopt/","page":"InferOpt tutorial","title":"InferOpt tutorial","text":"plot(training_losses; label=\"Training loss\")\nplot!(val_losses; label=\"Validation loss\")","category":"page"},{"location":"inferopt/","page":"InferOpt tutorial","title":"InferOpt tutorial","text":"The loss decreased, which is a good sign.","category":"page"},{"location":"inferopt/#Other-test-metrics","page":"InferOpt tutorial","title":"Other test metrics","text":"","category":"section"},{"location":"inferopt/","page":"InferOpt tutorial","title":"InferOpt tutorial","text":"We can also check the average optimality gap as another metric.","category":"page"},{"location":"inferopt/","page":"InferOpt tutorial","title":"InferOpt tutorial","text":"plot(objective_gap_history; title=\"Objective gap\")","category":"page"},{"location":"inferopt/","page":"InferOpt tutorial","title":"InferOpt tutorial","text":"The optimality gap also decreased:","category":"page"},{"location":"inferopt/","page":"InferOpt tutorial","title":"InferOpt tutorial","text":"@info \"Initial objective gap ≃ $(round(objective_gap_history[1], digits=2))%\"\n@info \"Final objective gap ≃ $(round(objective_gap_history[end], digits=2))%\"","category":"page"},{"location":"inferopt/","page":"InferOpt tutorial","title":"InferOpt tutorial","text":"Its value is now less than 1%. The training was a success 🎉","category":"page"},{"location":"inferopt/","page":"InferOpt tutorial","title":"InferOpt tutorial","text":"","category":"page"},{"location":"inferopt/","page":"InferOpt tutorial","title":"InferOpt tutorial","text":"This page was generated using Literate.jl.","category":"page"},{"location":"algorithms/","page":"Optimization algorithms","title":"Optimization algorithms","text":"EditURL = \"https://github.com/BatyLeo/StochasticVehicleScheduling.jl/blob/main/docs/src/literate/algorithms.jl\"","category":"page"},{"location":"algorithms/#Optimization-algorithms","page":"Optimization algorithms","title":"Optimization algorithms","text":"","category":"section"},{"location":"algorithms/","page":"Optimization algorithms","title":"Optimization algorithms","text":"In this section, we describe the various optimization algorithms implemented in this package, and illustrate them on the following small instance, with 25 tasks and 10 scenarios:","category":"page"},{"location":"algorithms/","page":"Optimization algorithms","title":"Optimization algorithms","text":"using StochasticVehicleScheduling\nusing Random\nRandom.seed!(1)  # fix the seed for reproducibility\ninstance = create_random_instance(; nb_tasks=25, nb_scenarios=10)\n\nusing Plots\nfig = plot()\nfor i in 1:(get_nb_tasks(instance) + 1)\n    task = instance.city.tasks[i]\n    (; start_point, end_point) = task\n    points = [(start_point.x, start_point.y), (end_point.x, end_point.y)]\n    plot!(fig, points; color=:black, label=\"\")\n    scatter!(\n        fig,\n        points;\n        marker=:rect,\n        markersize=10,\n        label=\"\",\n        series_annotations=[(\"$(i-1)\", 9), \"\"],\n    )\nend\nsavefig(fig, \"instance.png\"); # hide\nnothing #hide","category":"page"},{"location":"algorithms/","page":"Optimization algorithms","title":"Optimization algorithms","text":"(Image: instance)","category":"page"},{"location":"algorithms/#Heuristic-algorithms","page":"Optimization algorithms","title":"Heuristic algorithms","text":"","category":"section"},{"location":"algorithms/","page":"Optimization algorithms","title":"Optimization algorithms","text":"The first category of algorithms implemented are heuristics, which given good but not necessarily optimal solutions in a short amount of time.","category":"page"},{"location":"algorithms/#Deterministic-heuristic","page":"Optimization algorithms","title":"Deterministic heuristic","text":"","category":"section"},{"location":"algorithms/","page":"Optimization algorithms","title":"Optimization algorithms","text":"The first heuristic consists in solving a deterministic version of the instance, which minimizes vehicle costs plus travel costs of vehicles:","category":"page"},{"location":"algorithms/","page":"Optimization algorithms","title":"Optimization algorithms","text":"beginaligned\nmin   c_textvehuiclesum_ain delta^+(o) y_a + c_textdelaysum_ain aw_a y_a \nst  sum_ain delta^-(v) y_a = sum_ain delta^+(v) y_a  forall v inbar V\n sum_ain delta^-(v) y_a = 1  forall v inbar V\n y_a in 0 1 forall ain A\nendaligned","category":"page"},{"location":"algorithms/","page":"Optimization algorithms","title":"Optimization algorithms","text":"This is a linear flow program very easy to solve:","category":"page"},{"location":"algorithms/","page":"Optimization algorithms","title":"Optimization algorithms","text":"_, h_solution = solve_deterministic_VSP(instance)\nh_value = evaluate_solution(h_solution, instance)\nprintln(\"Heuristic solution value: $h_value\")","category":"page"},{"location":"algorithms/#Local-search","page":"Optimization algorithms","title":"Local search","text":"","category":"section"},{"location":"algorithms/","page":"Optimization algorithms","title":"Optimization algorithms","text":"A more advanced heuristic is the local search, which uses the deterministic solution as an initialization point, and try to improve it by applying elementary modifications to it.","category":"page"},{"location":"algorithms/","page":"Optimization algorithms","title":"Optimization algorithms","text":"ls_solution = heuristic_solution(instance; nb_it=1_000)\nls_value = evaluate_solution(ls_solution, instance)\nprintln(\"Local search solution value: $ls_value\")","category":"page"},{"location":"algorithms/","page":"Optimization algorithms","title":"Optimization algorithms","text":"We obtain a better solution than the previous heuristic!","category":"page"},{"location":"algorithms/#Exact-algorithms","page":"Optimization algorithms","title":"Exact algorithms","text":"","category":"section"},{"location":"algorithms/","page":"Optimization algorithms","title":"Optimization algorithms","text":"There are also two exact optimization algorithms implemented in this package.","category":"page"},{"location":"algorithms/#MIP-formulation","page":"Optimization algorithms","title":"MIP formulation","text":"","category":"section"},{"location":"algorithms/","page":"Optimization algorithms","title":"Optimization algorithms","text":"One way to solve the stochastic vehicle scheduling problem is to model it as the following linear program with quadratic constraints:","category":"page"},{"location":"algorithms/","page":"Optimization algorithms","title":"Optimization algorithms","text":"beginaligned\nmin_d y  c_textdelaydfrac1Ssumlimits_sin Ssumlimits_vin Vbackslashod d_v^s + c_textvehicle sumlimits_aindelta^+(o)y_a\ntextst  sum_aindelta^-(v)y_a = sum_aindelta^+(v)y_a forall vin bar V\n sum_aindelta^-(v)y_a = 1 forall vin bar V\n d_v^s geq gamma_v^s + sum_substackaindelta^-(v)  a=(u v) (d_u^s - delta_u v^s) y_a  forall vin bar V forall sin S\n d_v^sgeq gamma_v^s  forall vin bar V forall sin S\n y_ain01  forall ain A\nendaligned","category":"page"},{"location":"algorithms/","page":"Optimization algorithms","title":"Optimization algorithms","text":"Quadratic delay constraints can be linearized using Mc Cormick linearization.","category":"page"},{"location":"algorithms/","page":"Optimization algorithms","title":"Optimization algorithms","text":"mip_value, mip_solution = solve_scenarios(instance)\nprintln(\"MIP optimal value: $mip_value\")","category":"page"},{"location":"algorithms/","page":"Optimization algorithms","title":"Optimization algorithms","text":"The solution value is better than both heuristic values, as expected.","category":"page"},{"location":"algorithms/","page":"Optimization algorithms","title":"Optimization algorithms","text":"note: Note\nThis method does not scale well with tasks and scenarios number.","category":"page"},{"location":"algorithms/#Column-generation-formulation","page":"Optimization algorithms","title":"Column generation formulation","text":"","category":"section"},{"location":"algorithms/","page":"Optimization algorithms","title":"Optimization algorithms","text":"Another option is to use a column generation approach with variables y_P which equals one if route Pin mathycal P is selected. Cost of a path P: c_P^s = c_textvehicle + c_textdelaytimes sum_vin P d_v^s","category":"page"},{"location":"algorithms/","page":"Optimization algorithms","title":"Optimization algorithms","text":"beginaligned\nmin  frac1Ssum_sin Ssum_PinmathcalPc_P^s y_P \ntextst  sum_pni v y_P = 1  forall vin bar V  quad(lambda_vinmathbb R)\n y_Pin01  forall pin mathcalP \nendaligned","category":"page"},{"location":"algorithms/","page":"Optimization algorithms","title":"Optimization algorithms","text":"The associated sub-problem of the column generation formulation is a constrained shortest path problem of the form :","category":"page"},{"location":"algorithms/","page":"Optimization algorithms","title":"Optimization algorithms","text":"min_Pinmathcal P (c_P  - sum_vin Plambda_v)","category":"page"},{"location":"algorithms/","page":"Optimization algorithms","title":"Optimization algorithms","text":"It can be solved using generalized A^star algorithms (see theoretical details Parmentier 2017 and ConstrainedShortestPath.jl for its Julia implementation).","category":"page"},{"location":"algorithms/","page":"Optimization algorithms","title":"Optimization algorithms","text":"col_solution = column_generation_algorithm(instance)\ncol_value = evaluate_solution(col_solution, instance)\nprintln(\"Column generation optimal value: $col_value\")","category":"page"},{"location":"algorithms/","page":"Optimization algorithms","title":"Optimization algorithms","text":"The column generation solution has the same value as the MIP one, as expected (both are optimal).","category":"page"},{"location":"algorithms/","page":"Optimization algorithms","title":"Optimization algorithms","text":"note: Note\nColumn generation works better than the direct MIP, but still does not scale well when the number of tasks and scenarios increase too much. One way to do better is to use InferOpt.jl to build and learn an hybrid pipeline containing machine learning and combinatorial optimization layers. Checkout the InferOpt tutorial for an in-depth tutorial.","category":"page"},{"location":"algorithms/","page":"Optimization algorithms","title":"Optimization algorithms","text":"","category":"page"},{"location":"algorithms/","page":"Optimization algorithms","title":"Optimization algorithms","text":"This page was generated using Literate.jl.","category":"page"}]
}
